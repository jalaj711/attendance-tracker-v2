import 'package:attendance_tracker/models/subject_type.dart';
import 'package:drift/drift.dart';
import 'package:riverpod/riverpod.dart';

import 'connection/connection.dart' as impl;
import 'tables.dart';
// Manually generated by `drift_dev schema steps` - this file makes writing
// migrations easier. See this for details:
// https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
// import 'schema_versions.dart';

// Generated by drift_dev when running `build_runner build`
part 'database.g.dart';

@DriftDatabase(tables: [SubjectEntries, Attendance])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(impl.connect());

  AppDatabase.forTesting(DatabaseConnection connection) : super(connection);

  @override
  int get schemaVersion => 1;

  // @override
  // MigrationStrategy get migration {
  //   return MigrationStrategy(
  //     onUpgrade: stepByStep(),
  //     beforeOpen: (details) async {
  //       // Make sure that foreign keys are enabled
  //       await customStatement('PRAGMA foreign_keys = ON');

  //       if (details.wasCreated) {
  //         // Create a bunch of default values so the app doesn't look too empty
  //         // on the first start.
  //         // await batch((b) {

  //         // });
  //       }

  //       // This follows the recommendation to validate that the database schema
  //       // matches what drift expects (https://drift.simonbinder.eu/docs/advanced-features/migrations/#verifying-a-database-schema-at-runtime).
  //       // It allows catching bugs in the migration logic early.
  //       await impl.validateDatabaseSchema(this);
  //     },
  //   );
  // }
  static final StateProvider<AppDatabase> provider = StateProvider((ref) {
    final database = AppDatabase();
    ref.onDispose(database.close);

    return database;
  });

  Stream<List<Subject>> getAllSubjects() {
    final query = select(subjectEntries);

    return query.map((row) {
      return Subject(
          title: row.title,
          target: row.target,
          attended: row.attended,
          total_classes: row.totalClasses,
          id: row.id);
    }).watch();
  }
}
